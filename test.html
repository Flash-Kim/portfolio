hihi!! haahahahaha

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.StringTokenizer;

public class Solution {
	
	public static class Node implements Comparable<Node> {
		int next;
		int dist;
		
		public Node(int next, int dist) {
			this.next = next;
			this.dist = dist;
		}

		@Override
		public int compareTo(Node o) {
			return this.dist - o.dist;
		}
	}
	
	private static int N, M, J, C, F;
	private static StringTokenizer st;
	private static ArrayList<Node>[] arr;
	private static boolean[] visited;
	private static int together_max;
	
	public static void main(String[] args) throws IOException {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		
		int T = Integer.parseInt(br.readLine());
		
		for(int z=1; z<=T; z++) {
			
			// start each case
			
			st = new StringTokenizer(br.readLine());
			
			N = Integer.parseInt(st.nextToken());
			M = Integer.parseInt(st.nextToken());
			J = Integer.parseInt(st.nextToken());
			C = Integer.parseInt(st.nextToken());
			F = Integer.parseInt(st.nextToken());
			
			together_max = 0;
			
			arr = new ArrayList[N+1];
			for(int i=0; i<N+1; i++) {
				arr[i] = new ArrayList<Node>();
			}
			
			for(int i=0; i<M; i++) {
				st = new StringTokenizer(br.readLine());
				
				int a = Integer.parseInt(st.nextToken());
				int b = Integer.parseInt(st.nextToken());
				int c = Integer.parseInt(st.nextToken());
				
				arr[a].add(new Node(b, c));
				arr[b].add(new Node(a, c));
			}
			
			//bw.write(System.currentTimeMillis() + "\n");
			int[] j_dijk = dijkstra(J);
			//bw.write(System.currentTimeMillis() + "\n");
			int[] c_dijk = dijkstra(C);
			//bw.write(System.currentTimeMillis() + "\n");
			int[] f_dijk = dijkstra(F);
			//bw.write(System.currentTimeMillis() + "\n");
			
			//bw.write(Arrays.toString(j_dijk) + "\n");
			//bw.write(Arrays.toString(c_dijk) + "\n");
			//bw.write(Arrays.toString(f_dijk) + "\n");
			
			for(int i=F-1; i>0; i--) {
				//bw.write(i + "분석 고고\n");
				
				if(j_dijk[i] + f_dijk[i] == j_dijk[F] && c_dijk[i] + f_dijk[i] == c_dijk[F]) {
					together_max = f_dijk[i];
				}
			}
			
			bw.write("#" + z + " " + together_max + "\n");
			
			// end each case

		}
		
		bw.flush();
		br.close();
		bw.close();
		
	}

	private static int[] dijkstra(int num) {
		
		int[] cost = new int[N+1];
		Arrays.fill(cost, Integer.MAX_VALUE);
		
		PriorityQueue<Node> q = new PriorityQueue<Node>();
		
		q.add(new Node(num, 0));
		cost[num] = 0;
		
		while(!q.isEmpty()) {
			
			Node cur = q.poll();
			
			// continue
			if(cur.dist > cost[cur.next]) continue;
			
			for(Node n : arr[cur.next]) {
				//System.out.println(n.next + " " + n.dist);
				
				if(cost[n.next] > cost[cur.next] + n.dist) {
					cost[n.next] = cost[cur.next] + n.dist;
					q.add(new Node(n.next, cost[n.next]));
				}
				
			}
			
		}
		
		return cost;
	}
	
}
